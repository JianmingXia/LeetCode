# 阶乘后的零

## 题目描述
给定一个整数 n，返回 n! 结果尾数中零的数量。

### 示例
```
示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

### 说明
说明: 你算法的时间复杂度应为 O(log n) 。

## 思路分析
计算阶乘的 0，我本来的初步想法是，从 1 迭代到 n，计算：
- 能被 10 整除的数量
- 能被 5 整除的数量
- 能被 2 整除的数量

结果即为 能被 10 整除的数量 + min(能被 5 整除的数量, 能被 2 整除的数量)
最开始没有注意到时间复杂度，测试用例中有个超时案例：1808548329，这个时候我意识到我这个方法虽然可行——但明显不是最优，所以重新找规律

首先：
- 2 的数量肯定比 5 多
- 10 也可以拆解为 5 * 2
- 统计 5 出现的数量即可
  - 每隔 1 个 5，就会出现一个 10
  - 每隔 5 个 5，就会多出一个 10

是不是理解起来有点像 5 进制的感觉，即为题解。

## 代码
- 时间复杂度O(log n)
- 空间复杂度O(1)

```
/**
 * @param {number} n
 * @return {number}
 */
var trailingZeroes = function(n) {
  let count = 0;
  while(n) {
    n = parseInt(n / 5);

    count += n;
  }

  return count;
};
```